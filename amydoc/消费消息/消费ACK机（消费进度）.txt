参考：https://blog.csdn.net/prestigeding/article/details/79090848


问题解答：
    其实还是不明白为什么RocketMQ广播模式，如果消费失败，则丢弃？？？？

    因为广播模式有时候也必须确保每个消费者都成功消费，通常的场景为，通过MQ刷新本地缓存等。

1、消息消费进度概述
    首先简要阐述一下消息消费进度：

    消费者订阅消息消费队列（MessageQueue), 当生产者将消息负载发送到 MessageQueue 中时，
    消费订阅者开始消费消息，消息消费过程中，为了避免重复消费，需要一个地方存储消费进度（消费偏移量）。

    消息模式主要分为集群模式、广播模式：
        集群模式：一条消息被集群中任何一个消费者消费。
        广播模式：每条消息都被每一个消费者消费。

    广播模式，既然每条消息要被每一个消费者消费，则消费进度可以与消费者保存在一起，也就是本地保存。
    但由于集群模式下，一条消息只能被集群内的一个消费者消费，进度不能保存在消费端，只能集中保存在一个地方，比较合适的是在 Broker 端。

2、消息消费进度存储接口
    OffsetStore
    入口代码：DefaultMQPushConsumerImpl#start()。
        LocalFileOffsetStore ：消费模式之广播模式。消息进度以本地文件方式保存
        RemoteBrokerOffsetStore ：消费模式之集群模式。

3、LocalFileOffsetStore (广播模式)
    消息进度以本地文件方式保存。
    源码路径：org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore。



4、集群模式消费进度存储（RemoteBrokerOffsetStore）
    在集群模式下，多个消费者会负载到不同的消费队列上，
    因为消息消费进度是基于消息队列进行保存的，也就是不同的消费者之间的消费进度保存是不会存在并发的，
    但是在同一个消费者，非顺序消息消费时，一个消费者（多个线程）并发消费消息，比如m1 < m2,,但m2先消费完，
    此时是如何保存的消费进度呢？

    举个例子，如果m2的offset为5，而m1的offset为4，如果m2先消费完，保存进度为5，
    那m1消息消费完，保存进度为4，这样岂不乱来了，该如何处理呢？


问题答疑
    下面讨论还是基于非顺序消息：
    1、集群模式，一个消费组是多个线程消费该队列中的消息，并发执行，
        例如在q1中存在 m1,m2,m3,m4,m5，最后消费成功的顺序有可能是 m1,m3,m2,m5,m4,
        如果消费消息，就将该消息的offset存入offset中，岂不是会乱，
        如果一批拉取了多条消息，消费进度是如何保存的。


        要解决上述问题，我们移步到到调用offsetStore.updateStore方法，重点看一下那块逻辑：

        参考：ProcessQueue#removeMessage

        主要一下，msgTreeMap 的类型，TreeMap, 按消息的 offset 升序排序，返回的 result,
        如果 treemap 中不存在任何消息，那就返回该处理队列最大的偏移量+1，如果移除自己本批消息后，
        处理队列中，还存在消息，则返回该处理队列中最小的偏移量，也就是此时返回的偏移量有
        可能不是消息本身的偏移量，而是处理队列中最小的偏移量。

        优点：防止消息丢失（也就是没有消费到）。

        缺点：会造成消息重复消费。




















