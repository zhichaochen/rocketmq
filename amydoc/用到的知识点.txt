我的总结
    1、使用16进制表示数据 0x1
    2、16进制的 << 也是二进制的位移
    3、|= 不等于两个二进制数字相加：例如：
        也不是这样：10 | 10 = 10; 010 | 110 = 110;

        但是：在【两个数字大于等于二倍的情况下】：可以表示相加：
        （因为在相等的位上，不会有相等的 1。）
        比如：1、0x1，2、0x1 << 1，3、0x1 << 2，4、0x1 << 3


    4、& 0xFF ：相当于高位补零。

1、服务假死
    查看tomcat进程是存活的，查但是客户端的请求，没有响应。

2、0x1 << 3
    其中0x ：表示16进制，Java 中 乘号用 *
    << 左移：移动之后空出来的位置补0.
    ~ ：位运算中的 非，也就是 一元运算符中的not

    其中：
        1、或之后，相当于相加。
            PermName.PERM_READ | PermName.PERM_WRITE;：表示读写权限
            100 | 010 = 110 = 12

    为什么用16进制
        1：计算机硬件是0101二进制的，16进制刚好是2的倍数，更容易表达一个命令或者数据
        2：最早规定ASCII字符集采用的就是8bit(后期扩展了,但是基础单位还是8bit)，
            8bit用2个16进制直接就能表达出来，不管阅读还是存储都比其他进制要方便
        3：计算机中CPU运算也是遵照ASCII字符集，以16、32、64的这样的方式在发展，因此数据交换的时候16进制也显得更好
        4：为了统一规范，CPU、内存、硬盘我们看到都是采用的16进制计算

    16进制目前用的地方还是挺多的：
        1：网络编程，数据交换的时候需要对字节进行解析都是一个byte一个byte的处理，1个byte可以用0xFF两个16进制来表达
        2：数据存储，存储到硬件中是0101的方式，存储到系统中的表达方式都是byte方式
        3：一些常用值的定义，比如：我们经常用到的html中color表达，就是用的16进制方式，4个16进制位可以表达好几百万的颜色


    为啥使用两个 16进制就可以表示一个 Byte = 8bit。
        0xFF ： 两个16进制的F,其中F = 15.
        一个Byte 最大能表示的数字是 256-1 = 255
        那么15换成2进制就是1111，两个15就是 11111111，恰巧是 255。

        故而一个Byte完全可以使用两个16进制进行替换。

2.1、详解 【& 0xFF】 的作用。
    参考：https://blog.csdn.net/i6223671/article/details/88924481

    特别注意：
        个十百千万，其中【个位是低位】，【万位是高位】
    首先我们要都知道,
        &表示按位与,只有两个位同时为1,才能得到1,
        0x代表16进制数,0xff表示的数二进制1111 1111 占一个字节.
        和其进行&操作的数,最低8位,不会发生变化.

        其中：前为低位，后为高位。

        0000 0000 1111 1111 &

    &0xff都有哪些应用:
        1. 只是为了取得低八位
            通常配合移位操作符>>使用
             例如：(source >> 16) & 0xFF)

        2. 保证补码的一致性
            我们只关心二进制的机器数而不关注十进制的值,那么byte &0xff只是对其最低8位的复制,
            通常配合逻辑或 ‘’|’'使用,达到字节的拼接,但不保证其十进制真值不变


        3、总结：
            java中基本类型从小扩展到大的数据类型时候,正数因为符号位是0，无论如何都是补零扩展，但是负数补零扩展和补符号位扩展完全不同，

            负数补符号位扩展，保证十进制数不变
                例如 byte>>>int -127自动按照补符号位扩展，在高24位补符号位1，表示的十进制数不变

            补零扩展，保证补码的一致性，但是表示的十进制发生变化
                例如，本例中byte提升为int，&0xff的操作

2.2、PullSysFlag
    flag = 0;
    FLAG_COMMIT_OFFSET = 0x1;
    flag |= FLAG_COMMIT_OFFSET;

    直接赋值不就好了？ |=  有什么意义么？

    我的总结：|= 其实相当于二进制的相加。



3、NIO ByteBuffer的allocate与allocateDirect区别
    参考：https://blog.csdn.net/qq_36951116/article/details/87185240


    其中allocateDirect分配的字节缓冲区用中文叫做直接缓冲区（DirectByteBuffer），
    用allocate分配的ByteBuffer叫做堆字节缓冲区(HeapByteBuffer)..
4、CopyOnWriteArrayList


















